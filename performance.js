// Generated by CoffeeScript 2.3.2
var callAPI, getCoinPriceAtTime, getROI, https, loadData;

import {
  Betoken
} from "./betokenjs/betoken-obj.js";

import {
  stats,
  timer
} from "./betokenjs/helpers.js";

import {
  loadMetadata,
  loadTokenPrices,
  loadStats
} from "./betokenjs/data-controller.js";

https = require("https");

callAPI = async function(apiStr) {
  return (await (new Promise(function(resolve, reject) {
    return https.get(apiStr, function(res) {
      var rawData;
      rawData = "";
      res.on("data", function(chunk) {
        return rawData += chunk;
      });
      return res.on("end", function() {
        var parsedData;
        parsedData = JSON.parse(rawData);
        return resolve(parsedData);
      });
    }).on("error", reject);
  })));
};

getCoinPriceAtTime = async function(coin, time) {
  var apiStr, price;
  apiStr = `https://min-api.cryptocompare.com/data/pricehistorical?fsym=DAI&tsyms=${coin}&ts=${time}`;
  price = 1 / ((await callAPI(apiStr))).DAI[coin];
  return price;
};

loadData = async function() {
  // init betoken object
  window.betoken = new Betoken();
  await window.betoken.init();
  // load stats data from betoken
  await loadMetadata();
  await loadTokenPrices();
  return (await loadStats());
};

getROI = async function() {
  var betokenROIList, btcROIList, calcMean, calcSampleStd, ethROIList, excessReturnList, excessReturnStd, i, j, k, meanExcessReturn, now, phase, phaseLengths, phaseStart, rawROIs, ref, ref1, result, sharpeRatio, timestamps, x;
  await loadData();
  // get betoken ROI and time range
  phase = timer.phase();
  rawROIs = stats.raw_roi_data();
  now = Math.floor(new Date().getTime() / 1000);
  phaseStart = timer.phase_start_time();
  phaseLengths = timer.phase_lengths();
  betokenROIList = (function() {
    var j, ref, results;
    results = [];
    for (i = j = 0, ref = rawROIs.length - 1; (0 <= ref ? j <= ref : j >= ref); i = 0 <= ref ? ++j : --j) {
      results.push({
        roi: rawROIs[i][1],
        timestamp: {
          start: 0,
          end: 0
        }
      });
    }
    return results;
  })();
  switch (phase) {
    case 0:
      // invest & withdraw phase
      // use last cycle's data
      betokenROI[betokenROI.length - 1].timestamp.end = phaseStart - phaseLengths[2];
      betokenROI[betokenROI.length - 1].timestamp.start = endTimestamp - phaseLengths[1];
      break;
    case 1:
      // manage phase
      // use current data
      betokenROIList.push({
        roi: stats.cycle_roi().toNumber(),
        timestamp: {
          start: phaseStart,
          end: now
        }
      });
      break;
    case 2:
      // redeem commission phase
      // use data from manage phase
      betokenROIList.push({
        roi: stats.cycle_roi().toNumber(),
        timestamp: {
          start: phaseStart - phaseLengths[1],
          end: phaseStart
        }
      });
  }
  for (i = j = ref = betokenROIList.length - 2; (ref <= 0 ? j <= 0 : j >= 0); i = ref <= 0 ? ++j : --j) {
    betokenROIList[i].timestamp.end = betokenROIList[i + 1].timestamp.start - phaseLengths[0] - phaseLengths[2];
    betokenROIList[i].timestamp.start = betokenROIList[i].timestamp.end - phaseLengths[1];
  }
  // get the ROI data of BTC & ETH during the same time periods
  btcROIList = [];
  ethROIList = [];
  await Promise.all([
    Promise.all(betokenROIList.map(async function(x) {
      var btcEndPrice,
    btcROI,
    btcStartPrice;
      btcStartPrice = (await getCoinPriceAtTime("BTC",
    x.timestamp.start));
      btcEndPrice = (await getCoinPriceAtTime("BTC",
    x.timestamp.end));
      btcROI = (btcEndPrice - btcStartPrice) / btcStartPrice * 100;
      return btcROI;
    })).then(function(result) {
      return btcROIList = result;
    }),
    Promise.all(betokenROIList.map(async function(x) {
      var ethEndPrice,
    ethROI,
    ethStartPrice;
      ethStartPrice = (await getCoinPriceAtTime("ETH",
    x.timestamp.start));
      ethEndPrice = (await getCoinPriceAtTime("ETH",
    x.timestamp.end));
      ethROI = (ethEndPrice - ethStartPrice) / ethStartPrice * 100;
      return ethROI;
    })).then(function(result) {
      return ethROIList = result;
    })
  ]);
  // reformat data so that they're easier to use
  timestamps = (function() {
    var k, len, results;
    results = [];
    for (k = 0, len = betokenROIList.length; k < len; k++) {
      x = betokenROIList[k];
      results.push(x.timestamp);
    }
    return results;
  })();
  betokenROIList = (function() {
    var k, len, results;
    results = [];
    for (k = 0, len = betokenROIList.length; k < len; k++) {
      x = betokenROIList[k];
      results.push(x.roi);
    }
    return results;
  })();
  // calculate more stats for Betoken
  calcMean = function(list) {
    return list.reduce(function(accumulator, curr) {
      return accumulator + curr;
    }) / list.length;
  };
  calcSampleStd = function(list) {
    var mean, sampleStd, sampleVar;
    mean = calcMean(list);
    sampleVar = list.reduce(function(accumulator, curr) {
      return accumulator + Math.pow(curr - mean, 2);
    }, 0) / (list.length - 1);
    return sampleStd = Math.sqrt(sampleVar);
  };
  // Sharpe Ratio (against BTC, since inception)
  meanExcessReturn = calcMean(betokenROIList) - calcMean(btcROIList);
  excessReturnList = [];
  for (i = k = 0, ref1 = betokenROIList.length - 1; (0 <= ref1 ? k <= ref1 : k >= ref1); i = 0 <= ref1 ? ++k : --k) {
    excessReturnList[i] = betokenROIList[i] - btcROIList[i];
  }
  excessReturnStd = calcSampleStd(excessReturnList);
  sharpeRatio = meanExcessReturn / excessReturnStd;
  result = {
    ROI: {
      betoken: betokenROIList,
      btc: btcROIList,
      eth: ethROIList
    },
    'timestamps': timestamps,
    betokenStats: {
      ROI: {
        oneMonth: stats.cycle_roi(),
        sinceInception: stats.avg_roi()
      },
      SharpeRatio: sharpeRatio,
      Std: excessReturnStd
    }
  };
  return result;
};

window.getROI = getROI;
